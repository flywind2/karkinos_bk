package jp.ac.utokyo.rcast.karkinos.readssummary;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import jp.ac.utokyo.rcast.karkinos.exec.KarkinosProp;

public class DepthCounter implements java.io.Serializable {

	Map<Integer, CounterA> map = new TreeMap<Integer, CounterA>();
	List<Interval> lowcoverageList = new ArrayList<Interval>();

	double sumdepth = 0;
	long total = 0;

	double sumcdsdepth = 0;
	long totalcds;
	long over20x;
	long over10x;
	
	public float getMeanDepth() {

		double mean = sumdepth / (double) total;
		return (float) mean;

	}
	
	public float getMeanCDSDepth() {

		double mean =  sumcdsdepth  / (double) totalcds;
		return (float) mean;

	}
	
	public float getOver10X() {

		double mean =  over10x  / (double) totalcds;
		return (float) (mean*100);

	}
	public float getOver20X() {

		double mean =  over20x  / (double) totalcds;
		return (float) (mean*100);

	}

	public void add(String chr, int pos, int depth) {

		if (depth < KarkinosProp.mindepth) {

			boolean extendInterval = false;
			if (lowcoverageList.size() > 0) {
				int lastidx = lowcoverageList.size() - 1;
				Interval lastiv = lowcoverageList.get(lastidx);
				extendInterval = lastiv.extendInterval(chr, pos, depth);
				if (!extendInterval) {
					Interval iv = new Interval(chr, pos, depth);
					lowcoverageList.add(iv);
				}
			} else {
				Interval iv = new Interval(chr, pos, depth);
				lowcoverageList.add(iv);
			}
		}
		sumdepth = sumdepth + depth;
		total++;
		if (depth >= 1000) {
			depth = 1000;
			// }else if(depth>=300){
			// depth = (depth/100)*100;
		} else if (depth >= 10) {
			depth = (depth / 10) * 10;
		} else if (depth > 0) {
			depth = 1;
		}

		CounterA counter = null;
		if (!map.containsKey(depth)) {
			counter = new CounterA();
			map.put(depth, counter);
		} else {
			counter = map.get(depth);
		}
		counter.inc();
		
		if(onCDS(chr,pos)){
			sumcdsdepth = sumcdsdepth + depth;
			 totalcds++;
			 if(depth>=10){
				 over10x++;
			 }
			 if(depth>=20){
				 over20x++;
			 }
		}

	}

	private boolean onCDS(String chr, int pos) {
		
		if(ge!=null){
			return ge.onCDS(chr,pos);
						
		}		
		return false;
	}

	public List<Interval> getLowcoverageList() {
		return lowcoverageList;
	}

	public long getTotal() {
		return total;
	}

	public Map<Integer, CounterA> getMap() {
		return map;
	}

	public void merge(DepthCounter dc) {

		sumdepth = sumdepth + dc.sumdepth;
		total = total + dc.total;
		
		sumcdsdepth = sumcdsdepth +dc.sumcdsdepth;
		totalcds = totalcds + dc.totalcds;
		over20x  = over20x +dc.over20x;
		over10x  = over10x + dc.over10x;
		
		try {
			Set<Entry<Integer, CounterA>> set = dc.getMap().entrySet();
			for (Entry<Integer, CounterA> et : set) {

				int key = et.getKey();
				CounterA value = et.getValue();
				if (map.containsKey(key)) {
					CounterA thisval = map.get(key);
					thisval.cnt = thisval.cnt + value.cnt;
				} else {
					map.put(key, value);
				}

			}			
		} catch (Exception ex) {
		}
		try{
			
			lowcoverageList.addAll(dc.getLowcoverageList());
		}catch(Exception ex){
			
		}
		
	}

	GeneExons ge;
	public void setGeneExons(GeneExons ge) {
		this.ge = ge;	
	}

}
